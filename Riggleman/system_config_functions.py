import numpy as np

def PBC_particle(prtcl, l_x, l_y, l_z):
    if prtcl[0] < -l_x*0.5: prtcl[0] += l_x
    if prtcl[0] >= l_x*0.5: prtcl[0] -= l_x 
    
    if prtcl[1] < -l_y*0.5: prtcl[1] += l_y
    if prtcl[1] >= l_y*0.5: prtcl[1] -= l_y 
    
    if prtcl[2] < -l_z*0.5: prtcl[2] += l_z
    if prtcl[2] >= l_z*0.5: prtcl[2] -= l_z 

    return prtcl

def write_data(file, Atoms, Bonds, num_atom_types, num_bond_types, l_x, l_y, l_z):
    num_atoms = len(Atoms)
    num_bonds = len(Bonds)
    num_angles = 0; num_angle_types = 0
    num_dihedrals = 0; num_dihedral_types = 0
    num_impropers = 0; num_improper_types = 0
    
    otp = open(file, 'w')
    otp.write('Code generated by Han Zhang in Prof. Robert Riggleman group \n\n')
    
    otp.write('%d atoms\n' % num_atoms)
    otp.write('%d bonds\n' % num_bonds)
    otp.write('%d angles\n' % num_angles)
    otp.write('%d dihedrals\n' % num_dihedrals)
    otp.write('%d impropers\n\n' % num_impropers)
    
    otp.write('%d atom types\n' % num_atom_types)
    otp.write('%d bond types\n' % num_bond_types)
    otp.write('%d angle types\n' % num_angle_types)
    otp.write('%d dihedral types\n' % num_dihedral_types)
    otp.write('%d improper types\n\n' % num_improper_types)
    
    otp.write('%f %f xlo xhi\n' % (-l_x/2 , l_x/2))
    otp.write('%f %f ylo yhi\n' % (-l_y/2 , l_y/2))
    otp.write('%f %f zlo zhi\n\n' % (-l_z/2 , l_z/2))
    
    otp.write('Masses\n\n')
    for atom_type in range(num_atom_types):
        otp.write('%d %f\n' % (atom_type+1, 1.0))
    otp.write('\n')
    
    otp.write('Atoms\n\n')
    for atom in range(num_atoms):
        otp.write('%d %d %d %f %f %f\n' % (Atoms[atom,0], Atoms[atom,1], Atoms[atom,2], Atoms[atom,3], Atoms[atom,4], Atoms[atom,5]))
    otp.write('\n')
    
    otp.write('Bonds\n\n')
    for bond in range(num_bonds):
        otp.write('%d %d %d %d\n' % (Bonds[bond,0], Bonds[bond,1], Bonds[bond,2], Bonds[bond,3]))
    otp.write('\n')
      
    otp.close()    

def write_system_config(file, nu, phi, num_nu, f, b, excess_linker=1.0):
    num_clinkr = int(num_nu / (2 * nu)) # Number of cross-linkers if stoichiometric ratio = 1.0
    if excess_linker != 1.0: # Excess cross-linker option: vary the number of cross-linkers
        num_clinkr = int(excess_linker * num_clinkr)
    
    num_plymr_prtcl = num_nu + num_clinkr # Number of polymer particles (segments plus cross-linkers)
    num_systm_prtcl = int(num_plymr_prtcl / phi) # Number of system particles
    num_slvnt_prtcl = num_systm_prtcl - num_plymr_prtcl # Number of solvent particles
    
    num_chains = int(f*num_clinkr/2) # Number of polymer chains if stoichiometric ratio = 1.0
    if excess_linker != 1.0: # Excess cross-linker option: vary the number of cross-linkers
        n_th = int(num_nu / (2 * nu))
        num_chains = int(f*n_th/2)
        
    L = num_systm_prtcl ** (1/3) # Initial box size

    #Atom section: atom-ID molecule-ID atom-type x y z
    Atoms = np.zeros([num_systm_prtcl, 6])

    #atom-ID: first crosslinkers, then polymers, then solvent
    Atoms[:, 0] = np.arange(1, num_systm_prtcl+1, dtype=int)

    #molecule-ID: 0 for crosslinkers and solvents
    Atoms[:num_clinkr, 1] = np.zeros(num_clinkr)
    Atoms[num_clinkr:num_plymr_prtcl, 1] = (Atoms[num_clinkr:num_plymr_prtcl, 0] - num_clinkr - 1) // nu + 1 # double-slash // is floor division
    Atoms[num_plymr_prtcl:num_systm_prtcl, 1] = np.zeros(num_slvnt_prtcl)

    #atom-type: 1 for crosslinkers, 2 for polymers, 3 for endgroups on polymers, 4 for solvents
    Atoms[:num_clinkr, 2] = np.ones(num_clinkr)
    Atoms[num_clinkr:num_plymr_prtcl, 2] = np.ones(num_nu) * 2
    Atoms[num_clinkr:num_plymr_prtcl:nu, 2] = np.ones(num_chains) * 3
    Atoms[(num_clinkr+nu-1):(num_plymr_prtcl+nu-1):nu, 2] = np.ones(num_chains) * 3
    Atoms[num_plymr_prtcl:num_systm_prtcl, 2] = np.ones(num_slvnt_prtcl) * 4

    #x y z information
    Crosslinkers = -L/2 + L * np.random.rand(num_clinkr, 3) # Randomly distribute junctions into the simulation box
    Chain_Ends = -L/2 + L * np.random.rand(num_chains, 3) # Randomly distribute one end of polymer chain into the simulation box
    Atoms[:num_clinkr, 3:6] = Crosslinkers
    Atoms[num_clinkr:num_plymr_prtcl:nu, 3:6] = Chain_Ends

    for chain in range(num_chains):
        rand = np.random.randint(3)
        for j in range(1, nu):
            Atoms[num_clinkr+chain*nu+j, 3:6] = Atoms[num_clinkr+chain*nu+j-1, 3:6]
            Atoms[num_clinkr+chain*nu+j, 3+rand] = Atoms[num_clinkr+chain*nu+j-1, 3+rand] + b
            #Check PBC
            Atoms[num_clinkr+chain*nu+j, 3:6] = PBC_particle(Atoms[num_clinkr+chain*nu+j, 3:6], L, L, L)
    
    Atoms[num_plymr_prtcl:num_systm_prtcl, 3:6] = -L/2 + L * np.random.rand(num_slvnt_prtcl, 3) # Randomly distribute solvent into the simulation box
            
    #Bond section: ID type atom1 atom2
    num_bonds = (nu-1)*num_chains
    Bonds = np.zeros([num_bonds, 4])

    #ID
    Bonds[:, 0] = np.arange(1, num_bonds+1, dtype=int)

    #type
    Bonds[:, 1] = np.ones(num_bonds)

    #atom 1; atom 2
    atom = list(np.arange(num_clinkr+1, num_plymr_prtcl+1, dtype=int))
    end_1 = list(np.arange(num_clinkr+nu, num_plymr_prtcl+nu, nu, dtype=int))
    end_2 = list(np.arange(num_clinkr+1, num_plymr_prtcl+1, nu, dtype=int))

    atom_1 = np.array([x for x in atom if x not in end_1])
    atom_2 = np.array([x for x in atom if x not in end_2])

    Bonds[:, 2] = atom_1
    Bonds[:, 3] = atom_2

    if phi == 1.0:
        write_data(file, Atoms, Bonds, 3, 1, L, L, L)
    else:
        write_data(file, Atoms, Bonds, 4, 1, L, L, L)


